// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import 'dart:convert';
import 'dart:typed_data';

import 'package:firebase_ai/src/error.dart';
import 'package:firebase_ai/src/imagen_content.dart';
import 'package:firebase_ai/firebase_ai.dart';
import 'package:firebase_ai/src/api_client.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/annotations.dart';
import 'package:mockito/mockito.dart';
import 'mock.dart';
import 'imagen_test.mocks.dart'; // Generated by Mockito

// Mock HttpApiClient
@GenerateMocks([HttpApiClient])
void main() {
  setupFirebaseCoreMocks();

  setUpAll(() async {
    await Firebase.initializeApp(
      name: 'testApp',
      options: const FirebaseOptions(
        apiKey: 'test-api-key',
        appId: 'test-app-id',
        messagingSenderId: 'test-sender-id',
        projectId: 'test-project-id',
      ),
    );
  });

  group('ImagenInlineImage', () {
    test('fromJson with valid base64', () {
      final json = {
        'mimeType': 'image/png',
        'bytesBase64Encoded':
            'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
      };
      final image = ImagenInlineImage.fromJson(json);
      expect(image.mimeType, 'image/png');
      expect(image.bytesBase64Encoded, isA<Uint8List>());
      expect(image.bytesBase64Encoded, isNotEmpty);
    });

    test('fromJson with invalid base64', () {
      final json = {
        'mimeType': 'image/png',
        'bytesBase64Encoded': 'invalid_base64_string'
      };
      // Expect that the constructor throws an exception.
      expect(() => ImagenInlineImage.fromJson(json), throwsFormatException);
    });

    test('toJson', () {
      final image = ImagenInlineImage(
        mimeType: 'image/png',
        bytesBase64Encoded: Uint8List.fromList(utf8.encode('Hello, world!')),
      );
      final json = image.toJson();
      expect(json, {
        'mimeType': 'image/png',
        'bytesBase64Encoded': 'SGVsbG8sIHdvcmxkIQ==',
      });
    });
  });

  group('ImagenGCSImage', () {
    test('fromJson', () {
      final json = {
        'mimeType': 'image/jpeg',
        'gcsUri':
            'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg'
      };
      final image = ImagenGCSImage.fromJson(json);
      expect(image.mimeType, 'image/jpeg');
      expect(image.gcsUri,
          'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg');
    });

    test('toJson', () {
      final image = ImagenGCSImage(
        mimeType: 'image/jpeg',
        gcsUri:
            'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg',
      );
      final json = image.toJson();
      expect(json, {
        'mimeType': 'image/jpeg',
        'gcsUri':
            'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg',
      });
    });
  });

  group('ImagenGenerationResponse', () {
    test('fromJson with gcsUri', () {
      final json = {
        'predictions': [
          {
            'mimeType': 'image/jpeg',
            'gcsUri':
                'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg'
          },
          {
            'mimeType': 'image/jpeg',
            'gcsUri':
                'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_1.jpg'
          },
          {
            'mimeType': 'image/jpeg',
            'gcsUri':
                'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_2.jpg'
          },
          {
            'mimeType': 'image/jpeg',
            'gcsUri':
                'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_3.jpg'
          }
        ]
      };
      final response = ImagenGenerationResponse<ImagenGCSImage>.fromJson(json);
      expect(response.images, isA<List<ImagenGCSImage>>());
      expect(response.images.length, 4);
      expect(response.filteredReason, isNull);
    });

    test('fromJson with bytesBase64Encoded', () {
      final json = {
        'predictions': [
          {
            'mimeType': 'image/jpeg',
            'bytesBase64Encoded': 'SGVsbG8sIHdvcmxkIQ=='
          },
          {
            'mimeType': 'image/jpeg',
            'bytesBase64Encoded': 'SGVsbG8sIHdvcmxkIQ=='
          },
          {
            'mimeType': 'image/jpeg',
            'bytesBase64Encoded': 'SGVsbG8sIHdvcmxkIQ=='
          },
          {
            'mimeType': 'image/jpeg',
            'bytesBase64Encoded': 'SGVsbG8sIHdvcmxkIQ=='
          }
        ]
      };
      final response =
          ImagenGenerationResponse<ImagenInlineImage>.fromJson(json);
      expect(response.images, isA<List<ImagenInlineImage>>());
      expect(response.images.length, 4);
      expect(response.filteredReason, isNull);
    });

    test('fromJson with bytesBase64Encoded and raiFilteredReason', () {
      final json = {
        'predictions': [
          {
            'mimeType': 'image/png',
            'bytesBase64Encoded':
                'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
          },
          {
            'mimeType': 'image/png',
            'bytesBase64Encoded':
                'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
          },
          {
            'raiFilteredReason':
                'Your current safety filter threshold filtered out 2 generated images. You will not be charged for blocked images. Try rephrasing the prompt. If you think this was an error, send feedback.'
          }
        ]
      };
      final response =
          ImagenGenerationResponse<ImagenInlineImage>.fromJson(json);
      expect(response.images, isA<List<ImagenInlineImage>>());
      expect(response.images.length, 2);
      expect(response.filteredReason,
          'Your current safety filter threshold filtered out 2 generated images. You will not be charged for blocked images. Try rephrasing the prompt. If you think this was an error, send feedback.');
    });

    test('fromJson with only raiFilteredReason', () {
      final json = {
        'predictions': [
          {
            'raiFilteredReason':
                "Unable to show generated images. All images were filtered out because they violated Vertex AI's usage guidelines. You will not be charged for blocked images. Try rephrasing the prompt. If you think this was an error, send feedback. Support codes: 39322892, 29310472"
          }
        ]
      };
      // Expect that the constructor throws an exception.
      expect(() => ImagenGenerationResponse<ImagenInlineImage>.fromJson(json),
          throwsA(isA<ImagenImagesBlockedException>()));
    });

    test('fromJson with empty predictions', () {
      final json = {'predictions': {}};
      // Expect that the constructor throws an exception.
      expect(() => ImagenGenerationResponse<ImagenInlineImage>.fromJson(json),
          throwsA(isA<ServerException>()));
    });

    test('fromJson with unsupported type', () {
      final json = {
        'predictions': [
          {
            'mimeType': 'image/jpeg',
            'gcsUri':
                'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg'
          },
        ]
      };
      // Expect that the constructor throws an exception.
      expect(() => ImagenGenerationResponse<ImagenImage>.fromJson(json),
          throwsA(isA<ArgumentError>()));
    });
  });

  group('parseImagenGenerationResponse', () {
    test('with valid response', () {
      final json = {
        'predictions': [
          {
            'mimeType': 'image/jpeg',
            'gcsUri':
                'gs://test-project-id-1234.firebasestorage.app/images/1234567890123/sample_0.jpg'
          },
        ]
      };
      final response = parseImagenGenerationResponse<ImagenGCSImage>(json);
      expect(response.images, isA<List<ImagenGCSImage>>());
      expect(response.images.length, 1);
      expect(response.filteredReason, isNull);
    });

    test('with error', () {
      final json = {
        'error': {
          'code': 400,
          'message':
              "Image generation failed with the following error: The prompt could not be submitted. This prompt contains sensitive words that violate Google's Responsible AI practices. Try rephrasing the prompt. If you think this was an error, send feedback. Support codes: 42876398",
          'status': 'INVALID_ARGUMENT'
        }
      };
      // Expect that the function throws an exception.
      expect(() => parseImagenGenerationResponse<ImagenGCSImage>(json),
          throwsA(isA<ServerException>()));
    });
  });

  group('ImagenModel Tests', () {
    late ImagenModel imagenModel;
    late MockHttpApiClient mockClient;
    final app = Firebase.app('testApp');

    setUp(() {
      mockClient = MockHttpApiClient();
      imagenModel = ImagenModel._(
        app: app,
        model: 'gemini-1.5-flash', // Example model
        location: 'us-central1',
        useVertexBackend: true, // Assuming Vertex backend for these tests
        client: mockClient,
        // No default generationConfig or safetySettings for cleaner test isolation
      );
    });

    group('editImage', () {
      final sourceImageBytes = Uint8List.fromList(utf8.encode('source_image_bytes'));
      final sourceImage = ImagenInlineImage(bytesBase64Encoded: sourceImageBytes, mimeType: 'image/png');
      final maskImageBytes = Uint8List.fromList(utf8.encode('mask_image_bytes'));
      final maskImage = ImagenInlineImage(bytesBase64Encoded: maskImageBytes, mimeType: 'image/png');
      const prompt = 'a test prompt';

      test('should construct correct payload for mask-free editing', () async {
        // Assuming model has no default _generationConfig or _safetySettings for this test
        final config = ImagenEditingConfig.maskFree(image: sourceImage, numberOfImages: 2);
        final expectedPayload = {
          'instances': [
            {
              'prompt': prompt,
              'image': sourceImage.toJson(),
            }
          ],
          'parameters': {
            'sampleCount': 2, // From config
            // No other parameters expected if model defaults are null
          },
        };

        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => ImagenGenerationResponse<ImagenInlineImage>(images: [sourceImage])); // Dummy success

        await imagenModel.editImage(prompt, config: config);
        final captured = verify(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(
                captureAny, captureAny, captureAny))
            .captured;
        expect(captured[1], equals(expectedPayload));
      });

      test('should construct correct payload for full editing config', () async {
        final config = ImagenEditingConfig(
          image: sourceImage,
          mask: maskImage,
          maskDilation: 0.05,
          editSteps: 60,
          numberOfImages: 3,
          editMode: ImagenEditMode.inpaint,
          // negativePrompt, safetySettings, and generationConfig are no longer part of ImagenEditingConfig
        );

        // For this test, let's assume the model has some default _generationConfig and _safetySettings
        // to see them appear in the payload.
        final modelForFullTest = ImagenModel._(
          app: app,
          model: 'gemini-1.5-flash',
          location: 'us-central1',
          useVertexBackend: true,
          client: mockClient,
          generationConfig: ImagenGenerationConfig(
            aspectRatio: ImagenAspectRatio.landscape16x9,
            imageFormat: ImagenFormat.jpeg(compressionQuality: 80),
            addWatermark: false,
            negativePrompt: 'model-level blurry',
          ),
          safetySettings: ImagenSafetySettings(ImagenSafetyFilterLevel.blockLowAndAbove, ImagenPersonFilterLevel.blockAll),
        );

        final expectedPayload = {
          'instances': [
            {
              'prompt': prompt,
              'image': sourceImage.toJson(),
              'mask': maskImage.toJson(),
            }
          ],
          'parameters': {
            // From config
            'editMode': 'inpaint',
            'maskDilation': 0.05,
            'editSteps': 60,
            'sampleCount': 3,
            // From model-level settings
            'aspectRatio': '16:9',
            'negativePrompt': 'model-level blurry',
            'addWatermark': false,
            'outputOption': {'mimeType': 'image/jpeg', 'compressionQuality': 80},
            'personGeneration': 'dont_allow',
            'safetySetting': 'block_low_and_above',
          },
        };

        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => ImagenGenerationResponse<ImagenInlineImage>(images: [sourceImage]));

        await modelForFullTest.editImage(prompt, config: config); // Use modelForFullTest here
        final captured = verify(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(
                captureAny, captureAny, captureAny))
            .captured;
        expect(captured[1], equals(expectedPayload));
      });

      test('should parse successful response', () async {
        final config = ImagenEditingConfig.maskFree(image: sourceImage);
        final apiResponse = {
          'predictions': [
            {'bytesBase64Encoded': base64Encode(sourceImageBytes), 'mimeType': 'image/png'}
          ]
        };
        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => parseImagenGenerationResponse<ImagenInlineImage>(apiResponse));

        final response = await imagenModel.editImage(prompt, config: config); // Use default imagenModel
        expect(response.images.length, 1);
        expect(response.images.first.bytesBase64Encoded, equals(sourceImageBytes));
        expect(response.images.first.mimeType, 'image/png');
      });

      test('should throw ImagenImagesBlockedException for filtered response', () async {
        final config = ImagenEditingConfig.maskFree(image: sourceImage);
        final apiResponse = {
          'predictions': [
            {'raiFilteredReason': 'Blocked due to safety reasons'}
          ]
        };
         when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => parseImagenGenerationResponse<ImagenInlineImage>(apiResponse));

        expect(
            () => imagenModel.editImage(prompt, config: config), // Use default imagenModel
            throwsA(isA<ImagenImagesBlockedException>()));
      });

      test('should throw ServerException for error response', () async {
        final config = ImagenEditingConfig.maskFree(image: sourceImage);
        final apiResponse = {
          'error': {'code': 400, 'message': 'Bad request', 'status': 'INVALID_ARGUMENT'}
        };
        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => parseImagenGenerationResponse<ImagenInlineImage>(apiResponse));

        expect(
            () => imagenModel.editImage(prompt, config: config), // Use default imagenModel
            throwsA(isA<ServerException>()));
      });

      test('model-level defaults should be used when not overridden by ImagenEditingConfig', () async {
        // Initialize model with default settings
        final defaultSafety = ImagenSafetySettings(ImagenSafetyFilterLevel.blockMediumAndAbove, ImagenPersonFilterLevel.allowAdult);
        final defaultGeneration = ImagenGenerationConfig(
            negativePrompt: "default negative",
            numberOfImages: 1, // This will be overridden by config.numberOfImages if set, or config's default
            aspectRatio: ImagenAspectRatio.square1x1,
            addWatermark: true,
            imageFormat: ImagenFormat.png(),
        );

        final modelWithDefaults = ImagenModel._(
          app: app,
          model: 'gemini-1.5-flash',
          location: 'us-central1',
          useVertexBackend: true,
          client: mockClient,
          safetySettings: defaultSafety,
          generationConfig: defaultGeneration,
        );

        // ImagenEditingConfig now only has image and numberOfImages that could affect these global params
        final config = ImagenEditingConfig(
          image: sourceImage,
          numberOfImages: 2, // This will override defaultGeneration.numberOfImages for 'sampleCount'
          editMode: ImagenEditMode.outpaint, // Specific to edit
        );

        final expectedPayloadParameters = {
          // From config
          'sampleCount': 2,
          'editMode': 'outpaint',
          // From model-level defaults (defaultGeneration and defaultSafety)
          'aspectRatio': '1:1',
          'negativePrompt': 'default negative',
          'addWatermark': true,
          'outputOption': {'mimeType': 'image/png'},
          'personGeneration': 'allow_adult',
          'safetySetting': 'block_medium_and_above',
        };

        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => ImagenGenerationResponse<ImagenInlineImage>(images: [sourceImage]));

        await modelWithDefaults.editImage(prompt, config: config);
        final captured = verify(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(
                captureAny, captureAny, captureAny))
            .captured;
        // We are interested in the 'parameters' part of the payload (captured[1])
        final actualParameters = captured[1]['parameters'] as Map<String, dynamic>;
        expect(actualParameters, equals(expectedPayloadParameters));
      });
    });

    group('upscaleImage', () {
      final sourceImageBytes = Uint8List.fromList(utf8.encode('source_image_bytes_for_upscale'));
      final sourceImage = ImagenInlineImage(bytesBase64Encoded: sourceImageBytes, mimeType: 'image/jpeg');

      test('should construct correct payload for basic upscaling', () async {
        final expectedPayload = {
          'instances': [
            {'image': sourceImage.toJson()}
          ],
          'parameters': {
            'upscaleFactor': 'x2',
          },
        };
        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => ImagenGenerationResponse<ImagenInlineImage>(images: [sourceImage]));

        await imagenModel.upscaleImage(image: sourceImage, upscaleFactor: ImagenUpscaleFactor.x2);
        final captured = verify(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(
                captureAny, captureAny, captureAny))
            .captured;
        expect(captured[1], equals(expectedPayload));
      });

      test('should construct correct payload with optional safety and generation config', () async {
         final safety = ImagenSafetySettings(ImagenSafetyFilterLevel.blockLowAndAbove, ImagenPersonFilterLevel.blockAll);
         final generation = ImagenGenerationConfig(
            imageFormat: ImagenFormat.png(),
            addWatermark: true,
          );
        final expectedPayload = {
          'instances': [
            {'image': sourceImage.toJson()}
          ],
          'parameters': {
            'upscaleFactor': 'x4',
            'outputOption': {'mimeType': 'image/png'},
            'addWatermark': true,
            'personGeneration': 'dont_allow',
            'safetySetting': 'block_low_and_above',
          },
        };
         when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => ImagenGenerationResponse<ImagenInlineImage>(images: [sourceImage]));

        await imagenModel.upscaleImage(
            image: sourceImage,
            upscaleFactor: ImagenUpscaleFactor.x4,
            safetySettings: safety,
            generationConfig: generation,
        );
        final captured = verify(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(
                captureAny, captureAny, captureAny))
            .captured;
        expect(captured[1], equals(expectedPayload));
      });

      test('should parse successful upscale response', () async {
        final apiResponse = {
          'predictions': [
            {'bytesBase64Encoded': base64Encode(sourceImageBytes), 'mimeType': 'image/jpeg'}
          ]
        };
        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
             .thenAnswer((_) async => parseImagenGenerationResponse<ImagenInlineImage>(apiResponse));

        final response = await imagenModel.upscaleImage(image: sourceImage, upscaleFactor: ImagenUpscaleFactor.x2);
        expect(response.images.length, 1);
        expect(response.images.first.bytesBase64Encoded, equals(sourceImageBytes));
        expect(response.images.first.mimeType, 'image/jpeg');
      });

      test('should throw ImagenImagesBlockedException for filtered upscale response', () async {
        final apiResponse = {
          'predictions': [
            {'raiFilteredReason': 'Blocked due to safety reasons'}
          ]
        };
        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
             .thenAnswer((_) async => parseImagenGenerationResponse<ImagenInlineImage>(apiResponse));

        expect(
            () => imagenModel.upscaleImage(image: sourceImage, upscaleFactor: ImagenUpscaleFactor.x2),
            throwsA(isA<ImagenImagesBlockedException>()));
      });

      test('should throw ServerException for error in upscale response', () async {
         final apiResponse = {
          'error': {'code': 500, 'message': 'Internal server error', 'status': 'UNAVAILABLE'}
        };
        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => parseImagenGenerationResponse<ImagenInlineImage>(apiResponse));
        expect(
            () => imagenModel.upscaleImage(image: sourceImage, upscaleFactor: ImagenUpscaleFactor.x2),
            throwsA(isA<ServerException>()));
      });

      test('upscale method parameters should override model-level defaults', () async {
        final defaultSafety = ImagenSafetySettings(ImagenSafetyFilterLevel.blockNone, ImagenPersonFilterLevel.allowAll);
        final defaultGeneration = ImagenGenerationConfig(imageFormat: ImagenFormat.jpeg(), addWatermark: false);

        final modelWithDefaults = ImagenModel._(
          app: app,
          model: 'gemini-1.5-flash',
          location: 'us-central1',
          useVertexBackend: true,
          client: mockClient,
          safetySettings: defaultSafety,
          generationConfig: defaultGeneration,
        );

        final methodSafety = ImagenSafetySettings(ImagenSafetyFilterLevel.blockMediumAndAbove, null); // Override safety, keep person from default
        final methodGeneration = ImagenGenerationConfig(addWatermark: true, imageFormat: ImagenFormat.png()); // Override watermark and format

        final expectedPayloadParameters = {
          'upscaleFactor': 'x2',
          'outputOption': {'mimeType': 'image/png'}, // from methodGeneration
          'addWatermark': true, // from methodGeneration
          'personGeneration': 'allow_all', // from model default
          'safetySetting': 'block_medium_and_above', // from methodSafety
        };

        when(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(any, any, any))
            .thenAnswer((_) async => ImagenGenerationResponse<ImagenInlineImage>(images: [sourceImage]));

        await modelWithDefaults.upscaleImage(
          image: sourceImage,
          upscaleFactor: ImagenUpscaleFactor.x2,
          safetySettings: methodSafety,
          generationConfig: methodGeneration,
        );
        final captured = verify(mockClient.makeRequest<ImagenGenerationResponse<ImagenInlineImage>>(
                captureAny, captureAny, captureAny))
            .captured;
        expect(captured[1]['parameters'], equals(expectedPayloadParameters));
      });
    });
  });
}
