// Copyright 2025, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v25.3.2), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  PigeonError(
    code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.",
    details: ""
  )
}

private func isNullish(_ value: Any?) -> Bool {
  value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsFirebaseDatabaseMessages(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsFirebaseDatabaseMessages(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsFirebaseDatabaseMessages(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be
    // untrue.
    return false
  }
}

func deepHashFirebaseDatabaseMessages(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
    for item in valueList {
      deepHashFirebaseDatabaseMessages(value: item, hasher: &hasher)
    }
    return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys {
      hasher.combine(key)
      deepHashFirebaseDatabaseMessages(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

/// Generated class from Pigeon that represents data sent in messages.
struct DatabasePigeonSettings: Hashable {
  var persistenceEnabled: Bool?
  var cacheSizeBytes: Int64?
  var loggingEnabled: Bool?
  var emulatorHost: String?
  var emulatorPort: Int64?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DatabasePigeonSettings? {
    let persistenceEnabled: Bool? = nilOrValue(pigeonVar_list[0])
    let cacheSizeBytes: Int64? = nilOrValue(pigeonVar_list[1])
    let loggingEnabled: Bool? = nilOrValue(pigeonVar_list[2])
    let emulatorHost: String? = nilOrValue(pigeonVar_list[3])
    let emulatorPort: Int64? = nilOrValue(pigeonVar_list[4])

    return DatabasePigeonSettings(
      persistenceEnabled: persistenceEnabled,
      cacheSizeBytes: cacheSizeBytes,
      loggingEnabled: loggingEnabled,
      emulatorHost: emulatorHost,
      emulatorPort: emulatorPort
    )
  }

  func toList() -> [Any?] {
    [
      persistenceEnabled,
      cacheSizeBytes,
      loggingEnabled,
      emulatorHost,
      emulatorPort,
    ]
  }

  static func == (lhs: DatabasePigeonSettings, rhs: DatabasePigeonSettings) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DatabasePigeonFirebaseApp: Hashable {
  var appName: String
  var databaseURL: String?
  var settings: DatabasePigeonSettings

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DatabasePigeonFirebaseApp? {
    let appName = pigeonVar_list[0] as! String
    let databaseURL: String? = nilOrValue(pigeonVar_list[1])
    let settings = pigeonVar_list[2] as! DatabasePigeonSettings

    return DatabasePigeonFirebaseApp(
      appName: appName,
      databaseURL: databaseURL,
      settings: settings
    )
  }

  func toList() -> [Any?] {
    [
      appName,
      databaseURL,
      settings,
    ]
  }

  static func == (lhs: DatabasePigeonFirebaseApp, rhs: DatabasePigeonFirebaseApp) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DatabaseReferencePlatform: Hashable {
  var path: String

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DatabaseReferencePlatform? {
    let path = pigeonVar_list[0] as! String

    return DatabaseReferencePlatform(
      path: path
    )
  }

  func toList() -> [Any?] {
    [
      path,
    ]
  }

  static func == (lhs: DatabaseReferencePlatform, rhs: DatabaseReferencePlatform) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct DatabaseReferenceRequest: Hashable {
  var path: String
  var value: Any?
  var priority: Any?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DatabaseReferenceRequest? {
    let path = pigeonVar_list[0] as! String
    let value: Any? = pigeonVar_list[1]
    let priority: Any? = pigeonVar_list[2]

    return DatabaseReferenceRequest(
      path: path,
      value: value,
      priority: priority
    )
  }

  func toList() -> [Any?] {
    [
      path,
      value,
      priority,
    ]
  }

  static func == (lhs: DatabaseReferenceRequest, rhs: DatabaseReferenceRequest) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct UpdateRequest: Hashable {
  var path: String
  var value: [String: Any?]

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> UpdateRequest? {
    let path = pigeonVar_list[0] as! String
    let value = pigeonVar_list[1] as! [String: Any?]

    return UpdateRequest(
      path: path,
      value: value
    )
  }

  func toList() -> [Any?] {
    [
      path,
      value,
    ]
  }

  static func == (lhs: UpdateRequest, rhs: UpdateRequest) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TransactionRequest: Hashable {
  var path: String
  var transactionKey: Int64
  var applyLocally: Bool

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TransactionRequest? {
    let path = pigeonVar_list[0] as! String
    let transactionKey = pigeonVar_list[1] as! Int64
    let applyLocally = pigeonVar_list[2] as! Bool

    return TransactionRequest(
      path: path,
      transactionKey: transactionKey,
      applyLocally: applyLocally
    )
  }

  func toList() -> [Any?] {
    [
      path,
      transactionKey,
      applyLocally,
    ]
  }

  static func == (lhs: TransactionRequest, rhs: TransactionRequest) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct QueryRequest: Hashable {
  var path: String
  var modifiers: [[String: Any?]]
  var value: Bool?

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> QueryRequest? {
    let path = pigeonVar_list[0] as! String
    let modifiers = pigeonVar_list[1] as! [[String: Any?]]
    let value: Bool? = nilOrValue(pigeonVar_list[2])

    return QueryRequest(
      path: path,
      modifiers: modifiers,
      value: value
    )
  }

  func toList() -> [Any?] {
    [
      path,
      modifiers,
      value,
    ]
  }

  static func == (lhs: QueryRequest, rhs: QueryRequest) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct TransactionHandlerResult: Hashable {
  var value: Any?
  var aborted: Bool
  var exception: Bool

  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TransactionHandlerResult? {
    let value: Any? = pigeonVar_list[0]
    let aborted = pigeonVar_list[1] as! Bool
    let exception = pigeonVar_list[2] as! Bool

    return TransactionHandlerResult(
      value: value,
      aborted: aborted,
      exception: exception
    )
  }

  func toList() -> [Any?] {
    [
      value,
      aborted,
      exception,
    ]
  }

  static func == (lhs: TransactionHandlerResult, rhs: TransactionHandlerResult) -> Bool {
    deepEqualsFirebaseDatabaseMessages(lhs.toList(), rhs.toList())
  }

  func hash(into hasher: inout Hasher) {
    deepHashFirebaseDatabaseMessages(value: toList(), hasher: &hasher)
  }
}

private class FirebaseDatabaseMessagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return DatabasePigeonSettings.fromList(readValue() as! [Any?])
    case 130:
      return DatabasePigeonFirebaseApp.fromList(readValue() as! [Any?])
    case 131:
      return DatabaseReferencePlatform.fromList(readValue() as! [Any?])
    case 132:
      return DatabaseReferenceRequest.fromList(readValue() as! [Any?])
    case 133:
      return UpdateRequest.fromList(readValue() as! [Any?])
    case 134:
      return TransactionRequest.fromList(readValue() as! [Any?])
    case 135:
      return QueryRequest.fromList(readValue() as! [Any?])
    case 136:
      return TransactionHandlerResult.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class FirebaseDatabaseMessagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? DatabasePigeonSettings {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? DatabasePigeonFirebaseApp {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? DatabaseReferencePlatform {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? DatabaseReferenceRequest {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? UpdateRequest {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? TransactionRequest {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? QueryRequest {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? TransactionHandlerResult {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class FirebaseDatabaseMessagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    FirebaseDatabaseMessagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    FirebaseDatabaseMessagesPigeonCodecWriter(data: data)
  }
}

class FirebaseDatabaseMessagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = FirebaseDatabaseMessagesPigeonCodec(
    readerWriter: FirebaseDatabaseMessagesPigeonCodecReaderWriter()
  )
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol FirebaseDatabaseHostApi {
  func goOnline(app: DatabasePigeonFirebaseApp, completion: @escaping (Result<Void, Error>) -> Void)
  func goOffline(app: DatabasePigeonFirebaseApp,
                 completion: @escaping (Result<Void, Error>) -> Void)
  func setPersistenceEnabled(app: DatabasePigeonFirebaseApp, enabled: Bool,
                             completion: @escaping (Result<Void, Error>) -> Void)
  func setPersistenceCacheSizeBytes(app: DatabasePigeonFirebaseApp, cacheSize: Int64,
                                    completion: @escaping (Result<Void, Error>) -> Void)
  func setLoggingEnabled(app: DatabasePigeonFirebaseApp, enabled: Bool,
                         completion: @escaping (Result<Void, Error>) -> Void)
  func useDatabaseEmulator(app: DatabasePigeonFirebaseApp, host: String, port: Int64,
                           completion: @escaping (Result<Void, Error>) -> Void)
  func ref(app: DatabasePigeonFirebaseApp, path: String?,
           completion: @escaping (Result<DatabaseReferencePlatform, Error>) -> Void)
  func refFromURL(app: DatabasePigeonFirebaseApp, url: String,
                  completion: @escaping (Result<DatabaseReferencePlatform, Error>) -> Void)
  func purgeOutstandingWrites(app: DatabasePigeonFirebaseApp,
                              completion: @escaping (Result<Void, Error>) -> Void)
  func databaseReferenceSet(app: DatabasePigeonFirebaseApp, request: DatabaseReferenceRequest,
                            completion: @escaping (Result<Void, Error>) -> Void)
  func databaseReferenceSetWithPriority(app: DatabasePigeonFirebaseApp,
                                        request: DatabaseReferenceRequest,
                                        completion: @escaping (Result<Void, Error>) -> Void)
  func databaseReferenceUpdate(app: DatabasePigeonFirebaseApp, request: UpdateRequest,
                               completion: @escaping (Result<Void, Error>) -> Void)
  func databaseReferenceSetPriority(app: DatabasePigeonFirebaseApp,
                                    request: DatabaseReferenceRequest,
                                    completion: @escaping (Result<Void, Error>) -> Void)
  func databaseReferenceRunTransaction(app: DatabasePigeonFirebaseApp, request: TransactionRequest,
                                       completion: @escaping (Result<Void, Error>) -> Void)
  func databaseReferenceGetTransactionResult(app: DatabasePigeonFirebaseApp, transactionKey: Int64,
                                             completion: @escaping (Result<[String: Any?], Error>)
                                               -> Void)
  func onDisconnectSet(app: DatabasePigeonFirebaseApp, request: DatabaseReferenceRequest,
                       completion: @escaping (Result<Void, Error>) -> Void)
  func onDisconnectSetWithPriority(app: DatabasePigeonFirebaseApp,
                                   request: DatabaseReferenceRequest,
                                   completion: @escaping (Result<Void, Error>) -> Void)
  func onDisconnectUpdate(app: DatabasePigeonFirebaseApp, request: UpdateRequest,
                          completion: @escaping (Result<Void, Error>) -> Void)
  func onDisconnectCancel(app: DatabasePigeonFirebaseApp, path: String,
                          completion: @escaping (Result<Void, Error>) -> Void)
  func queryObserve(app: DatabasePigeonFirebaseApp, request: QueryRequest,
                    completion: @escaping (Result<String, Error>) -> Void)
  func queryKeepSynced(app: DatabasePigeonFirebaseApp, request: QueryRequest,
                       completion: @escaping (Result<Void, Error>) -> Void)
  func queryGet(app: DatabasePigeonFirebaseApp, request: QueryRequest,
                completion: @escaping (Result<[String: Any?], Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class FirebaseDatabaseHostApiSetup {
  static var codec: FlutterStandardMessageCodec { FirebaseDatabaseMessagesPigeonCodec.shared }
  /// Sets up an instance of `FirebaseDatabaseHostApi` to handle messages through the
  /// `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: FirebaseDatabaseHostApi?,
                    messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let goOnlineChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.goOnline\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      goOnlineChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        api.goOnline(app: appArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      goOnlineChannel.setMessageHandler(nil)
    }
    let goOfflineChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.goOffline\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      goOfflineChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        api.goOffline(app: appArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      goOfflineChannel.setMessageHandler(nil)
    }
    let setPersistenceEnabledChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.setPersistenceEnabled\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      setPersistenceEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let enabledArg = args[1] as! Bool
        api.setPersistenceEnabled(app: appArg, enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPersistenceEnabledChannel.setMessageHandler(nil)
    }
    let setPersistenceCacheSizeBytesChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.setPersistenceCacheSizeBytes\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      setPersistenceCacheSizeBytesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let cacheSizeArg = args[1] as! Int64
        api.setPersistenceCacheSizeBytes(app: appArg, cacheSize: cacheSizeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setPersistenceCacheSizeBytesChannel.setMessageHandler(nil)
    }
    let setLoggingEnabledChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.setLoggingEnabled\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      setLoggingEnabledChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let enabledArg = args[1] as! Bool
        api.setLoggingEnabled(app: appArg, enabled: enabledArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setLoggingEnabledChannel.setMessageHandler(nil)
    }
    let useDatabaseEmulatorChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.useDatabaseEmulator\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      useDatabaseEmulatorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let hostArg = args[1] as! String
        let portArg = args[2] as! Int64
        api.useDatabaseEmulator(app: appArg, host: hostArg, port: portArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      useDatabaseEmulatorChannel.setMessageHandler(nil)
    }
    let refChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.ref\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      refChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let pathArg: String? = nilOrValue(args[1])
        api.ref(app: appArg, path: pathArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      refChannel.setMessageHandler(nil)
    }
    let refFromURLChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.refFromURL\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      refFromURLChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let urlArg = args[1] as! String
        api.refFromURL(app: appArg, url: urlArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      refFromURLChannel.setMessageHandler(nil)
    }
    let purgeOutstandingWritesChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.purgeOutstandingWrites\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      purgeOutstandingWritesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        api.purgeOutstandingWrites(app: appArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      purgeOutstandingWritesChannel.setMessageHandler(nil)
    }
    let databaseReferenceSetChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.databaseReferenceSet\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      databaseReferenceSetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! DatabaseReferenceRequest
        api.databaseReferenceSet(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      databaseReferenceSetChannel.setMessageHandler(nil)
    }
    let databaseReferenceSetWithPriorityChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.databaseReferenceSetWithPriority\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      databaseReferenceSetWithPriorityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! DatabaseReferenceRequest
        api.databaseReferenceSetWithPriority(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      databaseReferenceSetWithPriorityChannel.setMessageHandler(nil)
    }
    let databaseReferenceUpdateChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.databaseReferenceUpdate\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      databaseReferenceUpdateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! UpdateRequest
        api.databaseReferenceUpdate(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      databaseReferenceUpdateChannel.setMessageHandler(nil)
    }
    let databaseReferenceSetPriorityChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.databaseReferenceSetPriority\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      databaseReferenceSetPriorityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! DatabaseReferenceRequest
        api.databaseReferenceSetPriority(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      databaseReferenceSetPriorityChannel.setMessageHandler(nil)
    }
    let databaseReferenceRunTransactionChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.databaseReferenceRunTransaction\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      databaseReferenceRunTransactionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! TransactionRequest
        api.databaseReferenceRunTransaction(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      databaseReferenceRunTransactionChannel.setMessageHandler(nil)
    }
    let databaseReferenceGetTransactionResultChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.databaseReferenceGetTransactionResult\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      databaseReferenceGetTransactionResultChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let transactionKeyArg = args[1] as! Int64
        api.databaseReferenceGetTransactionResult(app: appArg, transactionKey: transactionKeyArg) {
          result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      databaseReferenceGetTransactionResultChannel.setMessageHandler(nil)
    }
    let onDisconnectSetChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.onDisconnectSet\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      onDisconnectSetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! DatabaseReferenceRequest
        api.onDisconnectSet(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      onDisconnectSetChannel.setMessageHandler(nil)
    }
    let onDisconnectSetWithPriorityChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.onDisconnectSetWithPriority\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      onDisconnectSetWithPriorityChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! DatabaseReferenceRequest
        api.onDisconnectSetWithPriority(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      onDisconnectSetWithPriorityChannel.setMessageHandler(nil)
    }
    let onDisconnectUpdateChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.onDisconnectUpdate\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      onDisconnectUpdateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! UpdateRequest
        api.onDisconnectUpdate(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      onDisconnectUpdateChannel.setMessageHandler(nil)
    }
    let onDisconnectCancelChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.onDisconnectCancel\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      onDisconnectCancelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let pathArg = args[1] as! String
        api.onDisconnectCancel(app: appArg, path: pathArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      onDisconnectCancelChannel.setMessageHandler(nil)
    }
    let queryObserveChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.queryObserve\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      queryObserveChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! QueryRequest
        api.queryObserve(app: appArg, request: requestArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryObserveChannel.setMessageHandler(nil)
    }
    let queryKeepSyncedChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.queryKeepSynced\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      queryKeepSyncedChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! QueryRequest
        api.queryKeepSynced(app: appArg, request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryKeepSyncedChannel.setMessageHandler(nil)
    }
    let queryGetChannel = FlutterBasicMessageChannel(
      name:
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseHostApi.queryGet\(channelSuffix)",
      binaryMessenger: binaryMessenger, codec: codec
    )
    if let api {
      queryGetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! DatabasePigeonFirebaseApp
        let requestArg = args[1] as! QueryRequest
        api.queryGet(app: appArg, request: requestArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      queryGetChannel.setMessageHandler(nil)
    }
  }
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol FirebaseDatabaseFlutterApiProtocol {
  func callTransactionHandler(transactionKey transactionKeyArg: Int64,
                              snapshotValue snapshotValueArg: Any?,
                              completion: @escaping (Result<TransactionHandlerResult, PigeonError>)
                                -> Void)
}

class FirebaseDatabaseFlutterApi: FirebaseDatabaseFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }

  var codec: FirebaseDatabaseMessagesPigeonCodec {
    FirebaseDatabaseMessagesPigeonCodec.shared
  }

  func callTransactionHandler(transactionKey transactionKeyArg: Int64,
                              snapshotValue snapshotValueArg: Any?,
                              completion: @escaping (Result<TransactionHandlerResult, PigeonError>)
                                -> Void) {
    let channelName =
      "dev.flutter.pigeon.firebase_database_platform_interface.FirebaseDatabaseFlutterApi.callTransactionHandler\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(
      name: channelName, binaryMessenger: binaryMessenger, codec: codec
    )
    channel.sendMessage([transactionKeyArg, snapshotValueArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else if listResponse[0] == nil {
        completion(
          .failure(
            PigeonError(
              code: "null-error",
              message: "Flutter api returned null value for non-null return value.", details: ""
            )
          )
        )
      } else {
        let result = listResponse[0] as! TransactionHandlerResult
        completion(.success(result))
      }
    }
  }
}
