// Copyright 2023, the Chromium project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.
// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// The type of operation that generated the action code from calling
/// [TaskState].
enum PigeonStorageTaskState: Int {
  /// Indicates the task has been paused by the user.
  case paused = 0
  /// Indicates the task is currently in-progress.
  case running = 1
  /// Indicates the task has successfully completed.
  case success = 2
  /// Indicates the task was canceled.
  case canceled = 3
  /// Indicates the task failed with an error.
  case error = 4
}

/// Generated class from Pigeon that represents data sent in messages.
struct PigeonStorageFirebaseApp {
  var appName: String
  var tenantId: String?
  var bucket: String

  static func fromList(_ list: [Any?]) -> PigeonStorageFirebaseApp? {
    let appName = list[0] as! String
    let tenantId: String? = nilOrValue(list[1])
    let bucket = list[2] as! String

    return PigeonStorageFirebaseApp(
      appName: appName,
      tenantId: tenantId,
      bucket: bucket
    )
  }

  func toList() -> [Any?] {
    [
      appName,
      tenantId,
      bucket,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PigeonStorageReference {
  var bucket: String
  var fullPath: String
  var name: String

  static func fromList(_ list: [Any?]) -> PigeonStorageReference? {
    let bucket = list[0] as! String
    let fullPath = list[1] as! String
    let name = list[2] as! String

    return PigeonStorageReference(
      bucket: bucket,
      fullPath: fullPath,
      name: name
    )
  }

  func toList() -> [Any?] {
    [
      bucket,
      fullPath,
      name,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PigeonFullMetaData {
  var metadata: [String?: Any?]?

  static func fromList(_ list: [Any?]) -> PigeonFullMetaData? {
    let metadata: [String?: Any?]? = nilOrValue(list[0])

    return PigeonFullMetaData(
      metadata: metadata
    )
  }

  func toList() -> [Any?] {
    [
      metadata,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PigeonListOptions {
  /// If set, limits the total number of `prefixes` and `items` to return.
  ///
  /// The default and maximum maxResults is 1000.
  var maxResults: Int64
  /// The nextPageToken from a previous call to list().
  ///
  /// If provided, listing is resumed from the previous position.
  var pageToken: String?

  static func fromList(_ list: [Any?]) -> PigeonListOptions? {
    let maxResults = list[0] is Int64 ? list[0] as! Int64 : Int64(list[0] as! Int32)
    let pageToken: String? = nilOrValue(list[1])

    return PigeonListOptions(
      maxResults: maxResults,
      pageToken: pageToken
    )
  }

  func toList() -> [Any?] {
    [
      maxResults,
      pageToken,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PigeonSettableMetadata {
  /// Served as the 'Cache-Control' header on object download.
  ///
  /// See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control.
  var cacheControl: String?
  /// Served as the 'Content-Disposition' header on object download.
  ///
  /// See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition.
  var contentDisposition: String?
  /// Served as the 'Content-Encoding' header on object download.
  ///
  /// See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding.
  var contentEncoding: String?
  /// Served as the 'Content-Language' header on object download.
  ///
  /// See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language.
  var contentLanguage: String?
  /// Served as the 'Content-Type' header on object download.
  ///
  /// See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type.
  var contentType: String?
  /// Additional user-defined custom metadata.
  var customMetadata: [String?: String?]?

  static func fromList(_ list: [Any?]) -> PigeonSettableMetadata? {
    let cacheControl: String? = nilOrValue(list[0])
    let contentDisposition: String? = nilOrValue(list[1])
    let contentEncoding: String? = nilOrValue(list[2])
    let contentLanguage: String? = nilOrValue(list[3])
    let contentType: String? = nilOrValue(list[4])
    let customMetadata: [String?: String?]? = nilOrValue(list[5])

    return PigeonSettableMetadata(
      cacheControl: cacheControl,
      contentDisposition: contentDisposition,
      contentEncoding: contentEncoding,
      contentLanguage: contentLanguage,
      contentType: contentType,
      customMetadata: customMetadata
    )
  }

  func toList() -> [Any?] {
    [
      cacheControl,
      contentDisposition,
      contentEncoding,
      contentLanguage,
      contentType,
      customMetadata,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PigeonListResult {
  var items: [PigeonStorageReference?]
  var pageToken: String?
  var prefixs: [PigeonStorageReference?]

  static func fromList(_ list: [Any?]) -> PigeonListResult? {
    let items = list[0] as! [PigeonStorageReference?]
    let pageToken: String? = nilOrValue(list[1])
    let prefixs = list[2] as! [PigeonStorageReference?]

    return PigeonListResult(
      items: items,
      pageToken: pageToken,
      prefixs: prefixs
    )
  }

  func toList() -> [Any?] {
    [
      items,
      pageToken,
      prefixs,
    ]
  }
}

private class FirebaseStorageHostApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 128:
      return PigeonFullMetaData.fromList(readValue() as! [Any?])
    case 129:
      return PigeonListOptions.fromList(readValue() as! [Any?])
    case 130:
      return PigeonListResult.fromList(readValue() as! [Any?])
    case 131:
      return PigeonSettableMetadata.fromList(readValue() as! [Any?])
    case 132:
      return PigeonStorageFirebaseApp.fromList(readValue() as! [Any?])
    case 133:
      return PigeonStorageReference.fromList(readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class FirebaseStorageHostApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PigeonFullMetaData {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PigeonListOptions {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? PigeonListResult {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? PigeonSettableMetadata {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? PigeonStorageFirebaseApp {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? PigeonStorageReference {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class FirebaseStorageHostApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    FirebaseStorageHostApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    FirebaseStorageHostApiCodecWriter(data: data)
  }
}

class FirebaseStorageHostApiCodec: FlutterStandardMessageCodec {
  static let shared =
    FirebaseStorageHostApiCodec(readerWriter: FirebaseStorageHostApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol FirebaseStorageHostApi {
  func getReferencebyPath(app: PigeonStorageFirebaseApp, path: String, bucket: String?,
                          completion: @escaping (Result<PigeonStorageReference, Error>) -> Void)
  func setMaxOperationRetryTime(app: PigeonStorageFirebaseApp, time: Int64,
                                completion: @escaping (Result<Void, Error>) -> Void)
  func setMaxUploadRetryTime(app: PigeonStorageFirebaseApp, time: Int64,
                             completion: @escaping (Result<Void, Error>) -> Void)
  func setMaxDownloadRetryTime(app: PigeonStorageFirebaseApp, time: Int64,
                               completion: @escaping (Result<Void, Error>) -> Void)
  func useStorageEmulator(app: PigeonStorageFirebaseApp, host: String, port: Int64,
                          completion: @escaping (Result<Void, Error>) -> Void)
  func referenceDelete(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                       completion: @escaping (Result<Void, Error>) -> Void)
  func referenceGetDownloadURL(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                               completion: @escaping (Result<String, Error>) -> Void)
  func referenceGetMetaData(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                            completion: @escaping (Result<PigeonFullMetaData, Error>) -> Void)
  func referenceList(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                     options: PigeonListOptions,
                     completion: @escaping (Result<PigeonListResult, Error>) -> Void)
  func referenceListAll(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                        completion: @escaping (Result<PigeonListResult, Error>) -> Void)
  func referenceGetData(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                        maxSize: Int64,
                        completion: @escaping (Result<FlutterStandardTypedData?, Error>) -> Void)
  func referencePutData(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                        data: FlutterStandardTypedData, settableMetaData: PigeonSettableMetadata,
                        handle: Int64, completion: @escaping (Result<String, Error>) -> Void)
  func referencePutString(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                          data: String, format: Int64, settableMetaData: PigeonSettableMetadata,
                          handle: Int64, completion: @escaping (Result<String, Error>) -> Void)
  func referencePutFile(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                        filePath: String, settableMetaData: PigeonSettableMetadata?, handle: Int64,
                        completion: @escaping (Result<String, Error>) -> Void)
  func referenceDownloadFile(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                             filePath: String, handle: Int64,
                             completion: @escaping (Result<String, Error>) -> Void)
  func referenceUpdateMetadata(app: PigeonStorageFirebaseApp, reference: PigeonStorageReference,
                               metadata: PigeonSettableMetadata,
                               completion: @escaping (Result<PigeonFullMetaData, Error>) -> Void)
  func taskPause(app: PigeonStorageFirebaseApp, handle: Int64,
                 completion: @escaping (Result<[String: Any], Error>) -> Void)
  func taskResume(app: PigeonStorageFirebaseApp, handle: Int64,
                  completion: @escaping (Result<[String: Any], Error>) -> Void)
  func taskCancel(app: PigeonStorageFirebaseApp, handle: Int64,
                  completion: @escaping (Result<[String: Any], Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class FirebaseStorageHostApiSetup {
  /// The codec used by FirebaseStorageHostApi.
  static var codec: FlutterStandardMessageCodec { FirebaseStorageHostApiCodec.shared }
  /// Sets up an instance of `FirebaseStorageHostApi` to handle messages through the
  /// `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: FirebaseStorageHostApi?) {
    let getReferencebyPathChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.getReferencebyPath",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      getReferencebyPathChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let pathArg = args[1] as! String
        let bucketArg: String? = nilOrValue(args[2])
        api.getReferencebyPath(app: appArg, path: pathArg, bucket: bucketArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getReferencebyPathChannel.setMessageHandler(nil)
    }
    let setMaxOperationRetryTimeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.setMaxOperationRetryTime",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMaxOperationRetryTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let timeArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        api.setMaxOperationRetryTime(app: appArg, time: timeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMaxOperationRetryTimeChannel.setMessageHandler(nil)
    }
    let setMaxUploadRetryTimeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.setMaxUploadRetryTime",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMaxUploadRetryTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let timeArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        api.setMaxUploadRetryTime(app: appArg, time: timeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMaxUploadRetryTimeChannel.setMessageHandler(nil)
    }
    let setMaxDownloadRetryTimeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.setMaxDownloadRetryTime",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      setMaxDownloadRetryTimeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let timeArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        api.setMaxDownloadRetryTime(app: appArg, time: timeArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMaxDownloadRetryTimeChannel.setMessageHandler(nil)
    }
    let useStorageEmulatorChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.useStorageEmulator",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      useStorageEmulatorChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let hostArg = args[1] as! String
        let portArg = args[2] is Int64 ? args[2] as! Int64 : Int64(args[2] as! Int32)
        api.useStorageEmulator(app: appArg, host: hostArg, port: portArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      useStorageEmulatorChannel.setMessageHandler(nil)
    }
    let referenceDeleteChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceDelete",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceDeleteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        api.referenceDelete(app: appArg, reference: referenceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceDeleteChannel.setMessageHandler(nil)
    }
    let referenceGetDownloadURLChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceGetDownloadURL",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceGetDownloadURLChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        api.referenceGetDownloadURL(app: appArg, reference: referenceArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceGetDownloadURLChannel.setMessageHandler(nil)
    }
    let referenceGetMetaDataChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceGetMetaData",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceGetMetaDataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        api.referenceGetMetaData(app: appArg, reference: referenceArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceGetMetaDataChannel.setMessageHandler(nil)
    }
    let referenceListChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceList",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceListChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let optionsArg = args[2] as! PigeonListOptions
        api.referenceList(app: appArg, reference: referenceArg, options: optionsArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceListChannel.setMessageHandler(nil)
    }
    let referenceListAllChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceListAll",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceListAllChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        api.referenceListAll(app: appArg, reference: referenceArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceListAllChannel.setMessageHandler(nil)
    }
    let referenceGetDataChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceGetData",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceGetDataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let maxSizeArg = args[2] is Int64 ? args[2] as! Int64 : Int64(args[2] as! Int32)
        api.referenceGetData(app: appArg, reference: referenceArg, maxSize: maxSizeArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceGetDataChannel.setMessageHandler(nil)
    }
    let referencePutDataChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referencePutData",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referencePutDataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let dataArg = args[2] as! FlutterStandardTypedData
        let settableMetaDataArg = args[3] as! PigeonSettableMetadata
        let handleArg = args[4] is Int64 ? args[4] as! Int64 : Int64(args[4] as! Int32)
        api.referencePutData(
          app: appArg,
          reference: referenceArg,
          data: dataArg,
          settableMetaData: settableMetaDataArg,
          handle: handleArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referencePutDataChannel.setMessageHandler(nil)
    }
    let referencePutStringChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referencePutString",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referencePutStringChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let dataArg = args[2] as! String
        let formatArg = args[3] is Int64 ? args[3] as! Int64 : Int64(args[3] as! Int32)
        let settableMetaDataArg = args[4] as! PigeonSettableMetadata
        let handleArg = args[5] is Int64 ? args[5] as! Int64 : Int64(args[5] as! Int32)
        api.referencePutString(
          app: appArg,
          reference: referenceArg,
          data: dataArg,
          format: formatArg,
          settableMetaData: settableMetaDataArg,
          handle: handleArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referencePutStringChannel.setMessageHandler(nil)
    }
    let referencePutFileChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referencePutFile",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referencePutFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let filePathArg = args[2] as! String
        let settableMetaDataArg: PigeonSettableMetadata? = nilOrValue(args[3])
        let handleArg = args[4] is Int64 ? args[4] as! Int64 : Int64(args[4] as! Int32)
        api.referencePutFile(
          app: appArg,
          reference: referenceArg,
          filePath: filePathArg,
          settableMetaData: settableMetaDataArg,
          handle: handleArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referencePutFileChannel.setMessageHandler(nil)
    }
    let referenceDownloadFileChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceDownloadFile",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceDownloadFileChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let filePathArg = args[2] as! String
        let handleArg = args[3] is Int64 ? args[3] as! Int64 : Int64(args[3] as! Int32)
        api.referenceDownloadFile(
          app: appArg,
          reference: referenceArg,
          filePath: filePathArg,
          handle: handleArg
        ) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      referenceDownloadFileChannel.setMessageHandler(nil)
    }
    let referenceUpdateMetadataChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.referenceUpdateMetadata",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      referenceUpdateMetadataChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let referenceArg = args[1] as! PigeonStorageReference
        let metadataArg = args[2] as! PigeonSettableMetadata
        api
          .referenceUpdateMetadata(app: appArg, reference: referenceArg,
                                   metadata: metadataArg) { result in
            switch result {
            case let .success(res):
              reply(wrapResult(res))
            case let .failure(error):
              reply(wrapError(error))
            }
          }
      }
    } else {
      referenceUpdateMetadataChannel.setMessageHandler(nil)
    }
    let taskPauseChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.taskPause",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      taskPauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let handleArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        api.taskPause(app: appArg, handle: handleArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      taskPauseChannel.setMessageHandler(nil)
    }
    let taskResumeChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.taskResume",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      taskResumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let handleArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        api.taskResume(app: appArg, handle: handleArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      taskResumeChannel.setMessageHandler(nil)
    }
    let taskCancelChannel = FlutterBasicMessageChannel(
      name: "dev.flutter.pigeon.firebase_storage_platform_interface.FirebaseStorageHostApi.taskCancel",
      binaryMessenger: binaryMessenger,
      codec: codec
    )
    if let api {
      taskCancelChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let appArg = args[0] as! PigeonStorageFirebaseApp
        let handleArg = args[1] is Int64 ? args[1] as! Int64 : Int64(args[1] as! Int32)
        api.taskCancel(app: appArg, handle: handleArg) { result in
          switch result {
          case let .success(res):
            reply(wrapResult(res))
          case let .failure(error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      taskCancelChannel.setMessageHandler(nil)
    }
  }
}
