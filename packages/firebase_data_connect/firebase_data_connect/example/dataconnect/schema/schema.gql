type Person @table {
  name: String!
}
type DirectedBy @table(key: ["movie", "directedby"]) {
  directedby: Person!
  movie: Movie!
}
type Movie @table {
  title: String!
  description: String
  genre: String!
  releaseYear: Int
  rating: Float
}
type Thing @table {
  title: Any!
}
type TimestampHolder @table(key: ["timestamp"]) {
  timestamp: Timestamp!
  date: Date
}
# type Movie
#   # The below parameter values are generated by default with @table, and can be edited manually.
#   @table(name: "Movies", singular: "movie", plural: "movies", key: ["id"]) {
#   # implicitly calls @col to generates a column name. ex: @col(name: "movie_id")
#   # for UUID fields, @default(expr: "uuidV4()") is implicitly called
#   id: UUID!
#   title: String!
#   imageUrl: String!
#   releaseYear: Int
#   genre: String
#   rating: Float
#   description: String
#   tags: [String]
#   # Vectors
#   descriptionEmbedding: Vector @col(size:768) # vector
#   # Self Joins
#   sequelTo: Movie
# }

# # Movie Metadata
# # Movie - MovieMetadata is a one-to-one relationship
# type MovieMetadata
#   @table {
#   # @ref creates a field in the current table (MovieMetadata) that holds the primary key of the referenced type
#   # In this case, @ref(fields: "id") is implied
#   movie: Movie! @ref
#   # movieId: UUID <- this is created by the above @ref
#   director: String
#   # TODO: optional other fields
# }

# # Actors
# # Suppose an actor can participate in multiple movies and movies can have multiple actors
# # Movie - Actors (or vice versa) is a many to many relationship
# type Actor @table {
#   id: UUID!
#   imageUrl: String!
#   name: String! @col(name: "name", dataType: "varchar(30)")
#   biography: String
# }

# # Join table for many-to-many relationship for movies and actors
# # The 'key' param signifies the primary key(s) of this table
# # In this case, the keys are [movieId, actorId], the generated fields of the reference types [movie, actor]
# type MovieActor @table(key: ["movie", "actor"]) {
#   # @ref creates a field in the current table (MovieActor) that holds the primary key of the referenced type
#   # In this case, @ref(fields: "id") is implied
#   movie: Movie!
#   # movieId: UUID! <- this is created by the implied @ref, see: implicit.gql

#   actor: Actor!
#   # actorId: UUID! <- this is created by the implied  @ref, see: implicit.gql

#   role: String! # "main" or "supporting"
#   # TODO: optional other fields
# }

# # Users
# # Suppose a user can leave reviews for movies
# # user:reviews is a one to many relationship, movie:reviews is a one to many relationship, movie:user is a many to many relationship
# type User
#   @table {
#   id: String! @col(name: "user_auth")
#   username: String! @col(name: "username", dataType: "varchar(50)")
#   # The following are generated from the @ref in the Review table
#   # reviews_on_user
#   # movies_via_Review
# }

# # Join table for many-to-many relationship for users and favorite movies
# type FavoriteMovie
#   @table(name: "FavoriteMovies", key: ["user", "movie"]) {
#   # @ref is implicit
#   user: User!
#   movie: Movie!
# }

# # Join table for many-to-many relationship for users and favorite actors
# type FavoriteActor
#   @table(name: "FavoriteActors", key: ["user", "actor"]) {
#   user: User!
#   actor: Actor!
# }

# # Join table for many-to-many relationship for users and watched movies
# type WatchedMovie
#   @table(name: "WatchedMovies", key: ["user", "movie"]) {
#   user: User!
#   movie: Movie!
# }

# # Reviews
# type Review @table(name: "Reviews", key: ["movie", "user"]) {
#   id: UUID! @default(expr: "uuidV4()")
#   user: User!
#   movie: Movie!
#   rating: Int
#   reviewText: String
#   reviewDate: Date! @default(expr: "request.time")
# }
